"use strict";

var fs = require('fs'),
    _ = require('underscore');

_.string = require('underscore.string');
_.mixin(_.string.exports());

var parseFilterFile = function (filePath) {
    var data = fs.readFileSync(filePath, {encoding: 'utf-8'});
    var lines = _.lines(data);
    var filterLines = _.map(lines, function (line) {
        return parseFilterLine(line);
    });
    var relevantLines = _.filter(filterLines, function (filterLine) {
        return filterLine != null;
    });
    return new FilterFile(relevantLines);
};

var parseFilterLine = function (line) {
    var filterLine = new FilterLine();

    filterLine.original = line;

    filterLine.filterType = line.charAt(0);
    if (!_.contains(['P', '-', '+', 'H'], filterLine.filterType)) {
        if (!_.contains(['', '#'], filterLine.filterType)) {
            console.log('Unexpected filterType: ' + filterLine.filterType);
        }
        return null;
    }
    filterLine.filter = _.strRight(line, filterLine.filterType + ' ');
    filterLine.matcher = parseFilterRule(filterLine.filter);

    return filterLine;
};

var parseFilterRule = function (filterRule) {
    return {
        /**
         * Precondition: the parent directory of filePath already matched
         * @param filePath
         * @param baseDir
         * @param directory
         * @returns {boolean}
         */
        matches: function (filePath, baseDir, directory) {
            // Ensure basedir has a trailing slash
            if (!_.endsWith(baseDir, '/')) baseDir = baseDir + '/';
            var relativePath = _.strRight(filePath, baseDir);
            var regex;
            if (_.startsWith(filterRule, '/')) {
                // Matching relative from the basedir
                var matcherPart = _.strRight(filterRule, '/');
                matcherPart = escapeDotForFileName(matcherPart);
                if (directory && _.endsWith(filterRule, '/')) {
                    matcherPart = _.strLeftBack(matcherPart, '/') + '/?';
                }

                if (_.endsWith(matcherPart, '/***')) {
                    matcherPart.replace('/***', '(/?|/***)');
                }
                matcherPart.replace('***', '.*');

                if (_.endsWith(matcherPart, '***')) {
                    matcherPart = _.strLeftBack(matcherPart, '***');
                    if (_.endsWith(matcherPart, '/')) {
                        matcherPart = _.strLeftBack(matcherPart, '/');
                    }
                    matcherPart = matcherPart + '(/?|/.*)';
                }
                if (_.endsWith(matcherPart, '*')) {
                    matcherPart = _.strLeftBack(matcherPart, '*') + '[^/]*/?';
                }
                console.log('^' + matcherPart + '$');
                console.log(filterRule);
                regex = new RegExp('^' + matcherPart + '$');
                return regex.test(relativePath);
            } else {
                // Matching relative from the parent directory
                var matcherPart = filterRule;
                matcherPart = escapeDotForFileName(matcherPart);
                if (_.endsWith(matcherPart, '/')) {
                    matcherPart = _.strLeftBack(matcherPart, '/') + '/?';
                } else {
                    matcherPart = matcherPart + '/?';
                }
                regex = new RegExp('^.*/' + matcherPart + '$');
                return regex.test(filePath);
            }
        }
    }
};

var escapeDotForFileName = function (value) {
    return value.replace('.', '\\.');
};

var FilterFile = function FilterFile(filterLines) {
    this.filterLines = filterLines;

    this.shouldBackup = function (node, baseDir) {
        var shouldBackup = null;
        _.forEach(this.filterLines, function (filterLine) {
            if (shouldBackup == null) {
                shouldBackup = filterLine.shouldBackup(node, baseDir);
            }
        });
        if (shouldBackup == null) return true;
        return shouldBackup;
    };
};

var FilterLine = function FilterLine() {
    this.original = undefined;
    this.filterType = undefined;
    this.filter = undefined;
    this.matcher = undefined;
    this.matches = function (node, baseDir) {
        return this.matcher.matches(node.path, baseDir, node.isDirectory);
    };
    this.shouldBackup = function (node, baseDir) {
        switch (this.filterType) {
            case 'P':
                return null;
                break;
            case '-':
                if (this.matches(node, baseDir)) {
                    return false;
                }
                return null;
                break;
            case '+':
                if (this.matches(node, baseDir)) {
                    return true;
                }
                return null;
                break;
            case 'H':
                if (this.matches(node, baseDir)) {
                    return false;
                }
                return null;
                break;
            default:
                throw new Error('Filter file rule: \'' + filterLine.charAt(0) + '\'');
        }
    };
};

module.exports.parseFilterFile = parseFilterFile;
module.exports.parseFilterLine = parseFilterLine;
module.exports.parseFilterRule = parseFilterRule;
module.exports.FilterLine = FilterLine;
module.exports.FilterFile = FilterFile;